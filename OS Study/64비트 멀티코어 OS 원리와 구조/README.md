# 64비트 멀티코어 OS 원리와 구조
책을 읽어보며 새로 알게된 사실이나 잘못 알고 있었던 점들을 정리해보고자 하는 글입니다. 저는 Ubuntu 리눅스 환경에서 진행하였습니다.

# Index

# 2장 (개발환경 구축)
GCC(GNU Compiler Collection)를 설치해야 합니다. 리눅스 환경은 gcc를 쉽게 설치할 수 있으나 

```
sudo apt install gcc-multilib
```
위 패키지를 설치하여 gcc가 32비트를 지원하도록 할 수 있습니다. NASM(The Network Assembler), QEMU 역시 그냥 설치해주면 됩니다.

# 3장 (64비트 프로세스)
인텔 64비트 호환 프로세서(이하 **x86-64 프로세서**)에는 크게 다섯 가지 운영 모드가 있습니다.

- 리얼 모드: 프로세서의 초기 상태로서 `16비트 모드`로 동작하며 8086 프로세서와 호환되는 모드입니다. 최대 **1MB($2^{20}$)** 주소 공간을 지원합니다.
- 보호 모드: `32비트 모드`로 동작하며, 세그먼트, 페이징 보호, 멀티태스킹 등의 기능을 제공합니다. **4GB($2^{32}$)** 주소 공간을 지원합니다.
- IA-32e 모드: 32비트 호환 모드와 64비트 모드의 두 가지 서브모드로 구성됩니다. **16EB($2^{64}$)** 주소 공간을 지원합니다.
- 시스템 관리 모드: 전원 관리나 하드웨어 제어 같은 득수 기능을 제공합니다.
- 가상 8086 모드: 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드입니다.

위 모드 중 64비트 OS가 반드시 지원해야 하는 모드는 리얼 모드, 보호 모드, IA-32e 모드 중 64비트 서브 모드 총 세 가지가 있습니다. 

## 리얼 모드
프로세서가 어떤 상태나 모드에 있든, 전원이 켜지거나 리셋되면 프로세서는 리얼 모드로 진입합니다. 리얼 모드는 과거 16비트 프로세서와 동일하게 동작하며, BIOS의 여러 기능을 사용할 수 있습니다. 리얼 모드에서 하는 작업은 **OS 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경** 하는 것 밖에 없으나 대부분 작업을 어셈블리어로 처리합니다. 

## 보호 모드
보호 모드는 32비트 윈도우나 리눅스 OS가 동작하는 기본 모드로, IA-32e 모드로 전환하려면 반드시 거쳐야 하는 모드입니다. 최대 4G($2^{32}$) 주소 공간을 제공하며 멀티태스킹, 세그먼테이션, 페이징 등의 기능을 하드웨어적으로 지원합니다. 여러 기능을 지원하는만큼 레지스터와 자료구조 역시 다양합니다.

## IA-32e 모드
서브 모드로 32비트 호환 모드와 64비트 모드가 있습니다. 프로세서가 32비트 호환 모드일 때는 보호 모드에 있는 것처럼 동작하기에 32비트 코드를 그대로 실행할 수 있습니다.  <br>

![전환](./Images/ch3_1.png) <br>

위 그림은 각 운영 모드의 관계와 전환 조건을 나타내고 있습니다. 화살표가 연결되지 않은 모드끼리의 전환은 리셋이나 예외를 초래할 수 있습니다. 

아래 그림은 보호 모드와 IA-32e 모드에서의 레지스터를 나타내고 있습니다. <br>

![보호모드_레지스터](./Images/ch3_2.png) <br>
![IA3e레지스터](./Images/ch3_3.png) <br>

x86-64 프로세서에는 많은 레지스터가 있지만, OS 개발에 있어 큰 비중을 차지하는 레지스터는 **범용 레지스터, 세그먼트 레지스터, 컨트롤 레지스터** 세 가지입니다. 

## 범용 레지스터

범용 레지스터(General Purpose Register)는 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용합니다. 16비트와 32비트 모드를 지원하는 x86 계열(인텔 32비트 호환 프로세서)은 8개, 64비트 모드를 지원하는 x86-64 계열은 16개가 있습니다. x86-64 프로세서에는 x86 프로세서의 범용 레지스터 외에도 `R8 ~ R15`로 이름 붙여진 8개의 레지스터가 더 있는데, 차이점이 있다면 **특수한 용도가 정의되지 않았다** 는 것입니다. 다른 범용 레지스터들은 용도가 고정되지 않아 다양하게 사용될 수 있지만, 특정 명령어는 특정 레지스터와 같이 사용해야 합니다. 

|범용 레지스터 이름|용도|
|--------------|---|
|AX|산술 연산을 수행할 때 누산자로 사용|
|BX|데이터의 어드레스를 지정할 때 데이터 포인터로 사용|
|CX|루프 또는 문자열의 카운터|
|DX|I/O 어드레스를 지정할 때 사용되며, 산술 연산 수행할 때 보조 레지스터로 사용|
|SI|문자열에 관련된 작업을 할 때 원본 문자열의 인덱스로 활용|
|DI|문자열에 관련된 작업을 할 때 목적지 문자열의 인덱스로 활용|
|SP|스택의 포인터로 사용|
|BP|스택의 데이터에 접근할 때 데이터의 포인터로 사용|
|R8~R15| 다양한 용도로 사용|

그러나 레지스터들이 프로세서의 운영 모드마다 개별적으로 존재하는 것은 아닙니다. x86-64 프로세서는 64비트 크기의 범용 레지스터만 있으며 보호 모드나 리얼 모드일 때 **레지스터의 일부 영역만을** 사용하도록 처리하고 있습니다. 64비트 범용 레지스터는 `하위 32비트`, `16비트`, `8비트`의 크기로 구분하여 접근할 수 있고 레지스터에 **접두사(prefix)** 나 **접미사(postfix)** 를 붙여 접근하는 크기를 표시합니다. 대체로 64비트 크기 레지스터에는 RAX, RBP처럼 R 접두사가 붙고, 32비트 크기는 EAX,EBP처럼 E나 D 접두사, 16비트 크기는 안 붙거나 W 접미사가 붙습니다. 16비트 이하 크기는 상위 8비트와 하위 8비트로 구분하여 상위 8비트는 AH, BH처럼 끝자리에 H를 붙여 부르고, 하위 8비트는 AL, BL처럼 끝자리에 L을 붙입니다. 다음 그림에서 운영 모드별 접근 가능한 레지스터를 확인할 수 있습니다. <br>

![ch3_4](./Images/ch3_4.png) <br>

위 그림과 달리 **오퍼랜드 크기 접두사(0x66)** 와 **어드레스 크기 접두사(0x67)** 을 사용하면 리얼 모드에서도 32비트 레지스터에 접근할 수 있습니다(모드 전환하는 상황에서 주로 사용). 보호 모드에서 16비트 레지스터에 접근할 때도 마찬가지입니다. IA-32e 모드의 경우 기존의 두 가지 접두사와 새로 추가된 **REX** 접두사를 사용하여 다양한 크기의 레지스터를 사용할 수 있습니다. 여기서 접두사라 함은 기계어 instruction 앞에 66이나 67, 혹은 66 67을 붙이는 것을 의미합니다. 운영 모드에 따라 접두사를 결합하는 방법에 일정한 규칙이 있으며, 다음 표에서는 운영 모드와 접두사에 따라 오퍼랜드와 어드레스의 크기가 어떻게 변화하는지 나타내고 있습니다. <br>

![ch3_5](./Images/ch3_5.png) <br>

위의 표에서 눈여겨 봐야 할 점은 **IA-32e모드의 기본 오퍼랜드 크기가 32비트로 표시** 되었다는 것입니다. 기본 어드레스 크기는 64비트로 설계되었으나 기본 오퍼랜드 크기는 32비트로 설계되어 64비트 어드레스를 표현할 수 없고, **RIP 상대 어드레스** 라는 새로운 어드레스 계산 방식이 도입되었습니다. 

RIP 레지스터는 현재 실행 중인 명령의 주소를 나타내는 레지스터이고, 크기는 64비트입니다. RIP 레지스터의 값과 `32비트 오퍼랜드`를 통해 **64비트 주소 공간** 을 나타낼 수 있으며, 이게 RIP 상대 어드레스 지정방법입니다. 그러나 기본 오퍼랜드의 크기가 32비트라 위아래로 2G 범위까지만 표현이 가능하고, 이 범위를 벗어나려면 64비트 오퍼랜드와 관련있는 **REX** 접두사를 사용합니다. 이 접두사를 사용하면 오퍼랜드 크기가 64비트가 되어 64비트 어드레스를 모두 표현할 수 있게 됩니다. 

## 세그먼트 레지스터
세그먼트 레지스터(Segment Register)는 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 합니다. 리얼 모드에서는 단순히 고정된 크기의 어드레스 영역을 지정하는 역할만 하지만, 보호 모드와 IA-32e 모드에서는 **접근 권한**, **세그먼트의 시작 어드레스와 크기** 등을 지정하는 데에도 사용됩니다. 세그먼트 레지스터는 **CS, DS, SS, ES, FS, GS** 총 6개로 구성되며, 각 레지스터의 역할은 다음과 같습니다. <br>

![ch3_6](./Images/ch3_6.png) <br>

세그먼트 레지스터의 역할은 **주소 공간을 목적에 따라 구분하는 것** 이며, 이는 세그먼테이션이나 페이징 같은 메모리 관리 기법으로 이어집니다. 

## 컨트롤 레지스터
컨트롤 레지스터(Control Register)는 운영 모드를 변경하고, 현재 운영 중인 모드의 특정 기능을 제어하는 레지스터입니다. x86 프로세서에는 CR0, CR1, CR2, CR3, CR4 총 5개의 컨트롤 레지스터가 있고, x86-64 프로세서에는 CR8이 추가되어 총 6개가 있습니다. 각 레지스터의 역할은 다음 표와 같습니다. <br>

![ch3_7](./Images/ch3_7.png) <br>

컨트롤 레지스터는 리얼 모드와 보호 모드일 때는 32비트 크기이고, IA-32e 모드에서는 64비트 크기이나 제약사항이 있습니다. CR0, CR4, CR8 레지스터는 64비트 중 상위 32비트를 0으로 설정해야 하며, CR3 레지스터는 비트 40부터 비트 51까지 모두 0으로 설정해야 합니다. 대략적인 구조는 다음 그림과 같습니다. <br>

![ch3_8](./Images/ch3_8.png) <br>

## 운영 모드와 메모리 관리 기법
x86-64 프로세서에서 지원하는 메모리 관리 기법은 크게 두 가지: 세그멘테이션, 페이징이 있습니다. 세그멘테이션은 전체 영역을 원하는 크기로 나누어 관리하는 방식이고, 페이징은 일정한 단위로 잘라진 조각을 모아 원하는 크기로 관리하는 방식이라고 볼 수 있습니다. 메모리 관리 기법을 사용하려면 관련 레지스터에 특정한 자료구조를 설정해야 합니다. 

세그먼테이션은 세그먼트 레지스터에 세그먼트의 시작 주소 혹은 **디스크립터(Descriptor)** 라고 불리는 자료구조의 위치를 설정해야 합니다. 

페이징은 **CR3 레지스터에 페이지 디렉터리** 라고 불리는 자료구조의 물리 주소를 설정해야 사용할 수 있습니다. 운영 모드에 따라 지원하는 기능이 다르고, 같은 메모리 관리 기법을 사용해도 모드에 따라 필드의 의미가 달라지는 경우도 있으나, 큰 줄기는 변하지 않습니다. 

### 리얼 모드에서의 메모리 관리 방식
리얼 모드는 **최대 1MB** 까지 주소 공간을 사용하고 **세그먼테이션만** 지원합니다. 리얼 모드에서 세그먼트 크기는 `64K` 고정이고, 세그먼트의 시작 어드레스는 **세그먼트 레지스터에 직접 설정** 합니다. 세그먼테이션에서 세그먼트의 시작 어드레스는 코드나 메모리에 접근할 때 **기준 어드레스(Base Address)** 로 사용이 되는데, 그 관계는 아래 그림에서 나타내고 있습니다. <br>

![ch3_9](./Images/ch3_9.png) <br>

리얼 모드는 페이징을 사용하지 않으므로 물리 주소로 변환하는 방식이 비교적 간단합니다. 세그먼테이션을 거쳐 나온 주소가 바로 물리 주소가 됩니다. 리얼 모드의 세그먼테이션은 세그먼트 레지스터의 값에 범용 레지스터 값을 더하는 방식으로 동작합니다. 이때 최대 `16MB` 영역까지 접근하기 위해 16비트 크기 두 값을 그대로 더하는 것이 아니라, **세그먼트 레지스터에 16을 곱한 값** 을 기준 주소로 사용합니다. 즉 16비트의 최댓값인 65535($2^{16}-1$)에 16을 곱한 **1048560($2^{20}-16$)** 값을 사용하여 1MB까지 접근할 수 있게 되는 것입니다. 

세그먼트의 크기가 `64KB`인 이유는 범용 레지스터의 크기 때문입니다. 접두사를 특별하게 쓰지 않는 이상 범용 레지스터의 크기는 16비트이기 때문에 접근할 수 있는 범위 역시 0~65535(0xffff)가 됩니다. 보호 모드도 계산 방식이 비슷하지만, **페이징** 이 추가되어서 계산 결과가 물리 주소가 아닌 **선형 주소** 로 불리는 논리 주소로 바뀌었고, 선형 주소는 페이징을 거쳐 **물리 주소** 가 됩니다. 

### 보호 모드에서의 메모리 관리 방식
보호 모드는 **세그먼테이션** 과 **페이징** 을 모두 지원합니다. 보호 모드의 세그먼테이션은 리얼 모드의 세그먼테이션보다 많은 기능을 제공하며, 세그먼트 레지스터에 `세그먼트의 기준 주소`를 직접 설정하는 대신 **디스크립터 자료구조의 위치(Offset)** 를 설정하는 방식으로 바뀌었습니다. 세그먼트 레지스터의 명칭도 **세그먼트 셀렉터** 로 변경되었습니다. 

디스크립터: 메모리 영역의 정보를 저장하는 자료구조, 세그먼트에 대한 정보르르 나타내는 디스크립터는 `세그먼트 디스크립터` <br>
![ch3_10](./Images/ch3_10.png) <br>

위 그림에서 볼 수 있듯이 세그먼트의 시작 어드레스와 크기, 권한(Privilege), 타입(Type) 등의 정보가 있습니다. **특권 레벨(DPL, Descriptor Privilege Level)** 은 해당 세그먼트에 접근하기 위한 최소한의 권한을 나타내고, 특권 레벨은 `0~3 사이`의 값을 가집니다. 작은 숫자일 수록 권한이 높고, 세그먼트에 접근하려면 **현재 수행 중인 특권 레벨(CPL, Current Privilege Level)** 이 적어도 디스크립터에 설정된 권한과 같거나 높아야 합니다. 권한 조건을 만족하지 못하거나, 접근하는 어드레스가 세그먼트의 크기를 넘어서는 경우 예외가 발생합니다. 

보호 모드에서 세그먼트 레지스터는 **세그먼트 디스크립터의 위치** 를 가리킵니다. 세그먼트 디스크립터는 메모리 상에 위치하는 자료구조의 일종으로 **GDT(Global Descriptor Table)** 라는 곳에 모여 있습니다. GDT는 연속된 디스크립터의 집합이며, 최대 8192개의 디스크립터를 포함할 수 있는 테이블 형태의 자료구조입니다. GDT의 위치도 프로세서에 직접 알려줘야 하는데, **GDTR(Global Descriptor Table Register)** 레지스터가 이와 관련있습니다. `16비트 GDT 크기 필드`와 `32비트 기준 주소 필드`로 구성된 자료구조의 물리 주소를 넘겨받고, 프로세서는 이걸 저장했다가 세그먼트 셀렉터를 통해 어드레스에 접근할 때 GDT의 위치를 찾는데 참조합니다.

보호 모드에서도 주소를 계산할 때 리얼 모드처럼 세그먼트 레지스터의 기준 주소에 범용 레지스터의 값을 더해서 구합니다. 이렇게 계산한게 **선형 주소** 이며 프로세서는 선형 주소를 기반으로 물리 주소를 계산하여 실제 메모리에 접근합니다. 보호 모드에서는 리얼 모드와 다르게 세그먼트의 크기를 지정할 수 있으며, 해당 세그먼트의 어드레스에 접근할 때 이를 참조하고 기준 주소에 값을 더할 때 이 크기를 넘을 수 없습니다. 다음 그림은 세그먼트 레지스터와 세그먼트 디스크립터, 선형 주소의 관계를 보여줍니다. <br>

![ch3_11](./Images/ch3_11.png) <br>

리얼 모드와 다르게 선형 주소는 그대로 물리 주소가 되는게 아니라, **페이징의 입력값** 이 되며, 페이징을 안 쓰면 선형 주소가 그대로 물리 주소가 됩니다. 다음 그림은 세그먼테이션과 페이징을 통해 논리 주소를 물리 주소로 변환하는 과정입니다. <br>

![ch3_12](./Images/ch3_12.png) <br>

페이징은 물리 메모리를 **페이지(Page)** 라고 불리는 일정한 크기로 나누고, 선형 주소와 물리 주소를 나눠놓은 페이지로 연결하는 방식입니다. 페이징을 사용하면 물리 메모리 크기보다 큰 영역의 선형 주소도 물리 페이지를 연결하여 더 큰 주소 공간을 쓸 수 있습니다. 또한 **같은 물리 페이지를 여러 선형 주소에 연결** 함으로써 응용프로그램끼리 공유하는 메모리를 쉽게 처리하고, 페이징 자료구조를 따로따로 생성하여 물리 메모리에 중복되지 않게 연결하여 응용프로그램의 독립적인 주소 공간을 보장할 수 있습니다. 