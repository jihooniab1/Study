# AFL 분석
LKL을 활용한 파일 시스템 개발 과정에서 Janus와 기본 AFL의 **afl-fuzz.c** 파일을 분석, 비교해보고자 한다.

# 목차
- [1. American Fuzzy Lop](#american-fuzzy-lop-공부하기)
    - [1.1 technical detail](#technical-detail)

# American Fuzzy Lop 공부하기
## Technical Detail
### 1. 커버리지 측정
컴파일된 프로그램에 삽입된 **계측(instrumentation)** 은 대략적인 분기 실행 횟수와 함께 `분기(branch), edge` 커버리지를 캡처합니다. 분기 지점에 주입된 코드는 본질적으로 다음과 같습니다.
```
cur_location = <컴파일 타임 랜덤값>;
shared_mem[cur_location ^ prev_location]++;
prev_location = cur_location >> 1;
```
**cur_location** 값은 복잡한 프로젝트의 링킹 과정을 단순화하고 XOR 출력이 균등하게 분산되도록 하기 위해 무작위로 생성됩니다. 

**shared_mem[]** 배열은 호출자가 계측된 바이너리에 전달하는 **64KB 공유 메모리(SHM) 영역** 입니다. 출력 맵에서 설정된 모든 바이트는 계측된 코드에서 특정 **(branch_src, branch_dst)(분기 소스, 분기 목적지)** 튜플에 대한 히트로 간주할 수 있습니다. 

맵의 크기는 거의 모든 대상 타겟에서 충돌이 산발적으로 발생하도록 선택되었습니다. 일반적으로 이러한 타겟들은 2천에서 1만 개의 발견 가능한 분기 지점을 가집니다:

```
    분기 개수  | 충돌하는 튜플    | 예시 타겟
 -----------+---------------+------------------
       1,000 | 0.75%         | giflib, lzo
       2,000 | 1.5%          | zlib, tar, xz
       5,000 | 3.5%          | libpng, libwebp
      10,000 | 7%            | libxml
      20,000 | 14%           | sqlite
      50,000 | 30%           | -

>> 충돌 30퍼센트의 경우도 부정확하지만 여전히 유용함
```

동시에 맵의 크기는 수신하는 측에서 맵을 마이크로초 단위로 분석할 수 있을 만큼 충분히 작고, L2 캐시에 쉽게 맞을 수 있도록 작습니다.이러한 형태의 커버리지는 단순한 블록 커버리지보다 프로그램의 실행 경로에 대해 상당히 더 많은 정보를 제공합니다. 특히 다음과 같은 **실행추적(execution trace)** 을 쉽게 구별할 수 있습니다:
```
 A -> B -> C -> D -> E (튜플: AB, BC, CD, DE)
 A -> B -> D -> C -> E (튜플: AB, BD, DC, CE)

>> 블록 커버리지는 블록의 실행 여부만 판단해서 엣지 커버리지보다 정보가 부족함..
```

이는 기본 코드에서 미묘한 결함 조건을 찾는데 도움이 됩니다. 보안 취약점은 단순히 새로운 기본 블록에 도달하는 것보다는 예상치 못한 또는 잘못된 상태 전환과 더 자주 연관되기 때문입니다.

이 섹션 앞부분에서 보여준 의사코드 마지막 줄의 시프트 연산의 이유는 튜플의 방향성을 보존하고 (이것 없이는 **A^B가 B^A 와 구별이 안 됨**), 타이트 루프의 정체성을 유지하기 위함입니다(그렇지 않으면 A^A가 B^B와 명백히 같아짐).

### 2. 새로운 행동 탐지하기
퍼저는 이전 실행에서 **발견된 튜플들의 전역 맵** 을 유지합니다. 이 데이터는 개별 추적과 빠르게 비교될 수 있고, 단지 몇 개의 dword 또는 qword 크기의 명령어와 간단한 루프로 업데이트될 수 있습니다.

변형된 입력이 새로운 튜플을 포함하는 실행 추적을 생성하면 해당 입력 파일이 보존되고 나중에 추가 처리를 위해 라우팅됩니다. 실행 추적에서 **새로운 지역적 상태 전환** 을 트리거하지 않는 입력들(즉, 새로운 튜플을 생성하지 않는 입력들)은, 전체적인 제어 흐름 시퀀스가 고유하더라도 버려집니다. 

이 접근법은 복잡한 실행 추적의 계산적으로 집약적이고 취약한 전역 비교를 수행하지 않아도, 경로 폭발을 피하면서도 프로그램 상태의 세밀(fine-grained)하고 장기적인 탐색을 가능하게 합니다.

알고리즘의 특성을 설명하기 위해, 아래에 표시된 두 번째 trace는 **새로운 튜플(CA, AE)** 의 존재로 인해 실질적으로 새로운 것으로 간주될 것입니다:
```d
#1: A -> B -> C -> D -> E
#2: A -> B -> C -> A -> E
```

동시에 #2가 처리된 후, 다음 패턴은 현저히 다른 전체 실행 경로를 가짐에도 불구하고 고유한 것으로 보이지 않을 것입니다:
```
#3: A -> B -> C -> A -> B -> C -> A -> B -> C -> D -> E
```

새로운 튜플 감지에 더해, 퍼저는 또한 `대략적인(coarse)` 튜플 히트 카운트를 고려합니다. 이것들은 여러 버킷으로 나뉩니다:
```
1, 2, 3, 4-7, 8-15, 16-31, 32-127, 128+

>> 버킷1은 1번, 버킷2는 2번, ... 버킷 6은 16-31번 느낌
```

어느 정도 버킷의 수는 구현상의 산물로, 계측에 의해 생성된 8비트 카운터를 **8-position 비트맵** 에 in-place 매핑(실행 횟수를 바로 비트맵으로 변환)하는 것을 허용하며, 이는 퍼저 실행 파일이 각 튜플에 대해 이미 본 실행 카운트를 추적하기 위해 의존하는 것입니다. 

```
<8-position bitmap>
비트맵:  00000010
        ||||||||
        |||||||└─ 버킷1 (1번)
        ||||||└── 버킷2 (2번) ← 이 비트가 1
        |||||└─── 버킷3 (3번)  
        ||||└──── 버킷4 (4-7번)
        |||└───── 버킷5 (8-15번)
        ||└────── 버킷6 (16-31번)
        |└─────── 버킷7 (32-127번)
        └──────── 버킷8 (128+번)
```

단일 버킷의 범위 내 변화는 무시됩니다; 한 버킷에서 다른 버킷으로의 전환은 프로그램 제어 흐름에서 **흥미로운 변화** 로 플래그되고, 아래 섹션에서 설명하는 진화 프로세스(evolutionary process)로 라우팅됩니다.

히트 카운트 동작은 잠재적으로 흥미로운 제어 흐름 변화를 구별하는 방법을 제공합니다. 예를 들어 정상적으로 한 번만 히트되던 코드 블록이 두 번 실행되는 경우 등입니다. 동시에 이는 경험적으로 덜 주목할 만한 변화들, 예를 들어 루프가 47 사이클에서 48 사이클로 가는 것 같은 변화에는 둔감합니다. 카운터들은 또한 밀집된 추적 맵에서 튜플 충돌에 대해 어느 정도의 **우연한 면역성** 을 제공합니다.

실행은 메모리와 실행 시간 제한을 통해 엄격하게 제어됩니다. 기본적으로 타임아웃은 **초기 보정(initially-calibrated)된** 실행 속도의 5배로 설정되며, 20ms로 반올림됩니다. 공격적인 타임아웃은 커버리지를 1% 향상시키면서 100배 느린 경로로 빠져버려 퍼저 성능이 극도로 떨어지는 경우 같은 걸 막기 위함입니다; 우리는 실용적인 측면에서 이를 거부하고 퍼저가 같은 코드에 도달하는 덜 비싼 방법을 찾기를 희망합니다. 경험적 테스트는 더 관대한 시간 제한이 비용에 비해 가치가 없음을 강하게 시사합니다.

### 3. 입력 큐 진화시키기
새로운 상태 변화를 만들어낸 변이된 테스트 케이스들은 **입력 큐(input queue)** 에 들어가고, 미래 라운드의 시작점으로 사용됩니다. 이들은 기존 발견들을 보완하되 대체하지는 않습니다. 더 `탐욕적인 genetic algorithm`과 대조적으로, 이 접근법은 퍼저 도구가 기본 데이터 형식의 다양한 특징들을 **점진적으로** 탐색할 수 있게 합니다.

알고리즘을 통해 생성된 **합성 코퍼스(synthetic corpus)** 는 `뭔가 새롭거나 흥미로워 보이는 거`의 집합으로 향후 다른 테스팅 프로세스를 시드하는데 사용될 수 있습니다. 이 접근을 통해 대부분의 타겟에 대해 큐의 크기는 1K에서 10K 사이로 증가하고, 이 중 10-30 퍼센트 정도는 새로운 튜플의 발견, 나머지는 히트 카운트 변화에 영향을 줍니다.

다음 표는 