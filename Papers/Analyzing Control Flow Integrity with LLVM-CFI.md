# Summary for Analyzing Control Flow Integrity with LLVM-CFI

# Index

# Introduction
ROP 공격의 등장 이후 공격자와 방어자와의 수많은 연구가 이어졌다. 방어 측에서 **CFI**, **바이너리 재랜덤화**, **정보 은닉**, **코드 포인터 무결성** 과 같은 여러 연구를 함에 따라 공격자들도 더욱 정교한 기법들을 개발해나갔다. 

원칙적으로 현재 수많은 CFI 방어 기법들이 있고, 이론상 완벽한 CFI가 있더라도 공격 수행은 여전히 가능하다. 이러한 이유로 본 연구는 CFI 기법으로 보호되는 프로그램들이 얼마나 안전한지에 대해 답하고자 한다. CFI 기법이 적용된 후에도 공격자는 CFI에 의해 허용되는(`부정확성`으로 탐지를 피하는) 가젯들을 찾아 **code reuse attack** 을 수행할 수 있다. 이러한 공격은 훨씬 **프로그램에 의존적** 이 되고, 적용된 CFI 정책들은 보안에 대한 추론을 더 어렵게 만든다. 즉 공격자나 분석가나 CFI 기법이 적용된 후에도 유효한 가젯들을 검색해야 하는 과제에 직면하게 된다.

현재까지 아는 한 정적 CFI 기법을 서로 정적으로 모델링, 비교하는 도구나 적용된 방어 기법 집합을 인식하는 정적 CRA 제작 도구는 존재하니 않는다. 정적 패턴 기반 가젯 검색 도구나 동적 공격 구성 도구 등의 기존 도구들은 모두 대상 프로그램에 대한 깊은 지식이 부족하다. 

결과적으로 각 방어 기법이 적용될 때마다 유능한 평가 도구는 이상적으로 다음 기능을 가져야 한다:
1. 방어 기법을 최대한 정확하게 모델링
2. 런타임 메모리 제약에만 의존하지 않도록 프로그램 메타 데이터 사용
3. 보호된 프로그램의 정확한 의미론적 지식을 이용
4. 방어 기법이 배포된 후 남은 공격 표면에 대한 절대적인 분석 수치 제공

이를 통해 분석가는 어떤 CFI 기법이 더 적합하지 결정하고, 사용 가능한 가젯을 검색하여 CRA를 방어, 제작할 수 있다. 

본 논문에서는 최초로 최신 정적 CFI 방ㅇ어 기법들을 모델링하고 분석하는 데 사용되는 **정적 Clang/LLVM 기반** 컴파일러 프레임워크인 **LLVM-CFI** 를 제시한다. LLVM-CFI는 이러한 보호 기법들이 제공하는 보안 수준과 그러한 방어 기법이 배포된 후 남은 공격 표면을 결정할 수 있다. LLVM-CFI는 `control flow`가 전환될 수 있는 대상을 찾아 **COOP-like** 유사 공격의 한 단계를 자동화한다. 따라서 LLVM-CFI는 COOP-like 가젯 검색을 위한 첫 단계를 제공하지만, 주 목적은 정적 CFI 정책들을 서로 평가하는 것이다. 또한 LLVM-CFI가 CRA를 자동으로 구축할 수는 없지만, 구성에 도움을 제공한다. 

LLVM-CFI는 서로 다른 CFI 방어 기법들을 평가하는 통합 프레임워크로 직접적인 비교를 가능하게 한다.우리는 **CTF(Call-target Reduction)** 이라는 새로운 CFI 분석 지표를 도입한다. 이 지표는 CFI 기법이 적용된 후 얼마나 많은 호출 대상이 여전히 사용가능한지는 알려준다. LLVM-CFI는 여러 지표에 대해 CFI 정책을 분석할 수 있고, CTR은 그 중 하나이다.

